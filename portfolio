## 📄 要件定義（初期版）

### 1. 目的

- 転職活動での自己アピール
- 副業案件の獲得
- 自分の活動や考えを知ってもらう
- アウトプット習慣の定着
- 勉強の記録
- モチベーション維持

---

### 2. 想定ユーザー

- 採用担当者
- 発注担当者
- イベントや勉強会で知り合ったエンジニア
- 同じ職場の人

---

### 3. ユースケース（仮）

- 採用担当が短時間でスキル・実績を確認
- 発注担当が案件依頼の判断材料に使う
- エンジニア仲間が活動内容をフォロー
- 自分が活動履歴や成長を確認

---

### 4. ページ構成・内容

### Home

- ファーストビュー（名前・肩書き）
- 簡単な自己紹介
- 代表プロジェクト
- 簡単な技術力紹介（ランキングなど）
- お問い合わせフォーム
- （提案）最近の活動一覧

### About

- 詳細な自己紹介
- 経歴
- 興味・関心
- 自己PR
- （提案）スキルマップ全体図

### Projects

- 案件・個人PJのケーススタディ（課題→解決→技術→成果）
- 投稿記事一覧
- （提案）GitHub連携でコードサンプルリンク

### Analytics

- リポジトリ数、コミット数、スター数、フォロワー数
- 技術スタックランキング
- 月次推移グラフ
- スコア算出ルール
- GitHubの草グラフ

### Contact

- フォーム（名前 / メール / 用件 / 本文）

## **使用技術まとめ**

### **フロントエンド**

| 技術 | 採用理由 | 補足・代替案 |
| --- | --- | --- |
| **Next.js 14（App Router, TS）** | Next.jsを実務レベルで学びたい。ISR・画像最適化・Vercelとの親和性が高い。 | Nuxtでも可能だが、今回はReact資産を活かす方針。 |
| **Tailwind CSS** | 軽量でclass名設計不要。実装スピードが早い。 | CSS Modules / Vanilla Extract など。 |
| **shadcn/ui** | UI構築を短縮し、デザインに強くない部分を補完。 | MUI / Radix UIなども可。 |
| **Recharts（レーダー・棒・折れ線）** | JSXとの相性◎。必要十分な機能で軽量。 | Chart.jsは柔軟だがコード量が増えがち。 |
| **React Hook Form + Zod** | 軽量で高速、型安全なバリデーション。 | Formikは機能が厚くオーバーキル。 |
| **SWR + サーバ側fetch** | キャッシュ＋再検証が簡単。Nest APIとの相性◎。 | React Queryも可。 |
| **スパム対策（Honeypot＋軽Rate Limit）** | 公開フォームは高確率でスパムが来る。まずは低コスト対策から。 | CAPTCHAはUX低下するのでフェーズ2で。 |

---

### **バックエンド**

| 技術 | 採用理由 | 補足・代替案 |
| --- | --- | --- |
| **NestJS 10（REST）** | バックエンド設計を体系的に学ぶ。まずはRESTの基礎から。 | 必要に応じてGraphQLへ移行可。 |
| **PostgreSQL（Neon）** | AuthやStorage不要なので軽量なマネージドDBで十分。 | Supabaseは認証やStorage込み。 |
| **Prisma + 必要時のみ生SQL** | 型安全・スキーマ追従・可読性の高さ。生SQLは性能や特殊処理用。 | Drizzle ORMなども可。 |
| **取り込み（RSS Pull + GitHub Webhook）** | 記事は確実に取得、GitHubはリアルタイム化。 | 全ポーリングはレート制限や遅延あり。 |
| **ジョブ（Vercel Cron → Nest `/recalc`）** | 日次スコア確定で表示を軽量化。 | 重くなればBullMQ+Redisに移行。 |
| **送信（Resend + Slack Webhook）** | 問い合わせの見落とし防止と二重化。 | SMTP直送は管理負担あり。 |

---

### **インフラ / 運用**

| 技術 | 採用理由 | 補足・代替案 |
| --- | --- | --- |
| **Front=Vercel / Back=Railway / DB=Neon** | NextはVercelが最短、Nestは常駐サーバ必須。 | Render / Fly.ioでも可。 |
| **監視：Vercel Analytics + Sentry** | 障害検知と可視化で信頼感UP。 | LogtailやAxiomでも可。 |
| **pnpm + Node 20 LTS** | 高速・安定・互換性広い。 | npm/Yarnでも動くがpnpm優勢。 |

---

### **スコアリング設計**

- **ルールJSON + 計算ライブラリ**
    - 配点・時系列減衰（半減期）をJSONで管理。
    - 計算ロジックはNest/Nextで共通利用可。
    - デメリット：生埋め込みより初期構築に時間がかかる。
    - メリット：仕様変更が即反映可能、将来GoやPythonでも再利用可。

## 作業メモ

- 実際のサイトを作る時の一般的な方法でやってみたいので、chatgptに聞いた順番でやってみる
- 要件定義をやった
- 使用技術まとめてみた
- githubに専用ディレクトリ作成
    - git管理したいため
    - アウトプットしたいため
- readmeに要件定義と使用技術を書いた
- chatgptに食わせたら以下の項目を追加してくれた
    - Quick Start
    - Environment Variables
    - Scripts（よく使うコマンド）
    - MVP（Minimum Viable Product）
    - API（Backend / 予定含む）
    - Data Model（Prisma 最小）
    - Data Flow（文章でOK）
    - Deploy
    - Security
    - Roadmap

### README.md

```markdown
# ポートフォリオ（要件定義 & セットアップ）

## 📄 要件定義（初期版）

### 1. 目的

- 転職活動での自己アピール
- 副業案件の獲得
- 自分の活動や考えを知ってもらう
- アウトプット習慣の定着
- 勉強の記録
- モチベーション維持

### 2. 想定ユーザー

- 採用担当者
- 発注担当者
- イベントや勉強会で知り合ったエンジニア
- 同じ職場の人

### 3. ユースケース（仮）

- 採用担当が短時間でスキル・実績を確認
- 発注担当が案件依頼の判断材料に使う
- エンジニア仲間が活動内容をフォロー
- 自分が活動履歴や成長を確認

### 4. ページ構成・内容

#### Home

- ファーストビュー（名前・肩書き）
- 簡単な自己紹介
- 代表プロジェクト
- 簡単な技術力紹介（ランキングなど）
- お問い合わせフォーム
- （提案）最近の活動一覧

#### About

- 詳細な自己紹介
- 経歴
- 興味・関心
- 自己 PR
- （提案）スキルマップ全体図

#### Projects

- 案件・個人 PJ のケーススタディ（課題 → 解決 → 技術 → 成果）
- 投稿記事一覧
- （提案）GitHub 連携でコードサンプルリンク

#### Analytics

- リポジトリ数、コミット数、スター数、フォロワー数
- 技術スタックランキング
- 月次推移グラフ
- スコア算出ルール
- GitHub の草グラフ

#### Contact

- フォーム（名前 / メール / 用件 / 本文）

## 🛠 使用技術まとめ

### フロントエンド

| 技術                                       | 採用理由                                                                   | 補足・代替案                                       |
| ------------------------------------------ | -------------------------------------------------------------------------- | -------------------------------------------------- |
| **Next.js 14（App Router, TS）**           | Next.js を実務レベルで学びたい。ISR・画像最適化・Vercel との親和性が高い。 | Nuxt でも可能だが、今回は React 資産を活かす方針。 |
| **Tailwind CSS**                           | 軽量で class 名設計不要。実装スピードが早い。                              | CSS Modules / Vanilla Extract など。               |
| **shadcn/ui**                              | UI 構築を短縮し、デザインに強くない部分を補完。                            | MUI / Radix UI なども可。                          |
| **Recharts（レーダー・棒・折れ線）**       | JSX との相性 ◎。必要十分な機能で軽量。                                     | Chart.js は柔軟だがコード量が増えがち。            |
| **React Hook Form + Zod**                  | 軽量で高速、型安全なバリデーション。                                       | Formik は機能が厚くオーバーキル。                  |
| **SWR + サーバ側 fetch**                   | キャッシュ＋再検証が簡単。Nest API との相性 ◎。                            | React Query も可。                                 |
| **スパム対策（Honeypot ＋軽 Rate Limit）** | 公開フォームは高確率でスパムが来る。まずは低コスト対策から。               | CAPTCHA は UX 低下するのでフェーズ 2 で。          |

### バックエンド

| 技術                                       | 採用理由                                                        | 補足・代替案                         |
| ------------------------------------------ | --------------------------------------------------------------- | ------------------------------------ |
| **NestJS 10（REST）**                      | バックエンド設計を体系的に学ぶ。まずは REST の基礎から。        | 必要に応じて GraphQL へ移行可。      |
| **PostgreSQL（Neon）**                     | Auth や Storage 不要なので軽量なマネージド DB で十分。          | Supabase は認証や Storage 込み。     |
| **Prisma + 必要時のみ生 SQL**              | 型安全・スキーマ追従・可読性の高さ。生 SQL は性能や特殊処理用。 | Drizzle ORM なども可。               |
| **取り込み（RSS Pull + GitHub Webhook）**  | 記事は確実に取得、GitHub はリアルタイム化。                     | 全ポーリングはレート制限や遅延あり。 |
| **ジョブ（Vercel Cron → Nest `/recalc`）** | 日次スコア確定で表示を軽量化。                                  | 重くなれば BullMQ+Redis に移行。     |
| **送信（Resend + Slack Webhook）**         | 問い合わせの見落とし防止と二重化。                              | SMTP 直送は管理負担あり。            |

### インフラ / 運用

| 技術                                      | 採用理由                                       | 補足・代替案                    |
| ----------------------------------------- | ---------------------------------------------- | ------------------------------- |
| **Front=Vercel / Back=Railway / DB=Neon** | Next は Vercel が最短、Nest は常駐サーバ必須。 | Render / Fly.io でも可。        |
| **監視：Vercel Analytics + Sentry**       | 障害検知と可視化で信頼感 UP。                  | Logtail や Axiom でも可。       |
| **pnpm + Node 20 LTS**                    | 高速・安定・互換性広い。                       | npm/Yarn でも動くが pnpm 優勢。 |

### スコアリング設計

- **ルール JSON + 計算ライブラリ**
  - 配点・時系列減衰（半減期）を JSON で管理。
  - 計算ロジックは Nest/Next で共通利用可。
  - **メリット**：即調整・再利用性高い　**デメリット**：初期構築の手間は少し増える。

## 📁 Repository Layout

```
portfolio/ # 親（ローカル作業用：ワークスペース）
├─ frontend/ # Next.js
└─ backend/ # Nest.js
```

## 🚀 Quick Start

### package.json（親）

```json
{
  "private": true,
  "name": "portfolio",
  "workspaces": ["frontend", "backend"],
  "scripts": {
    "dev": "concurrently \"pnpm -C frontend dev\" \"pnpm -C backend start:dev\""
  },
  "devDependencies": { "concurrently": "^8.2.2" }
}
```

### 起動コマンド

```bash
# 親ディレクトリで
pnpm i
pnpm dev   # → frontend: http://localhost:3000 , backend: http://localhost:3001
```

## 🔑 Environment Variables

### 共通（frontend / backend）

```ini
DATABASE_URL=postgresql://USER:PASSWORD@HOST:PORT/DB
```

### backend 専用

```ini
PORT=3001
GITHUB_WEBHOOK_SECRET=changeme
SLACK_WEBHOOK_URL=（任意）
RESEND_API_KEY=（任意）
```

## 📜 Scripts（よく使うコマンド）

```bash
# 親
pnpm dev                          # front/back 同時起動

# frontend
pnpm -C frontend dev
pnpm -C frontend prisma db push

# backend
pnpm -C backend start:dev
pnpm -C backend prisma db push
```

## 🥇 MVP（Minimum Viable Product）

この状態になったら"最初の完成"とする

- `/（Home）`が表示される（FV/代表 PJ はダミーで OK）
- `/analytics` にレーダーチャートが出る（ダミー or `/api/scores`の値）
- backend の `GET /api/scores?days=90` が 200 で JSON 返す
- DB に Activity / ScoreDaily テーブルが存在（prisma db push 済み）

## ✅ Definition of Done（チェックリスト）

- [ ] `pnpm dev` 1 コマンドで Next(3000) と Nest(3001) が同時に立ち上がる
- [ ] `.env` 設定で DB 接続が動く
- [ ] フロントとバック間の API 通信が成功
- [ ] 表示が最低限の UI で崩れていない

```

- BEの要件定義というものもあることに気づき、そこをやっていく
- まず最初に決める5項目を決める
    - **データモデル（テーブル）**
        - 何を記録する？→ `Activity`（記事/PR/プロジェクト） と `ScoreDaily`（日次スコア）
        - 最低フィールド：
            - `Activity{id, actionId, happenedAt, url*, source, status, meta(json), tags(json)}`
            - `ScoreDaily{id, skillId, date, points}`（`skillId+date`は一意）
            
    - **APIコントラクト（入出力の形）**
        - `GET /api/scores?days=90` → `{"react":123.4,"next":98.7}`
        - `GET /api/ingest/rss/pull?url=...` → `{"ok":true,"count":12}`
        - `POST /api/ingest/github/webhook`（署名必須） → `204 No Content`
        - `POST /api/recalc` → `{"ok":true,"count":42}`
    - **ワークフロー（何がトリガで何が起きる？）**
        - RSSを手動/定期で取る → `Activity`にUPSERT
        - PRがマージ → WebhookでUPSERT
        - 毎日03:00 → `Activity→ScoreDaily`を再計算
    - **セキュリティ方針（最小）**
        - WebhookはHMAC署名検証（`x-hub-signature-256`）
        - APIキーは**サーバ側のみ**、フロントに出さない
        - Contactなどはレート制限（例：IPあたり1分1回）
    - **運用先とポート**
        - Back: Railway / Port `3001`
        - DB: Neon(PostgreSQL)
        - Cron: Vercel Cron → `POST /api/recalc`
- 次に決める10項目とかあるみたいだけど後回しにする
    - アクション定義（配点）
    - スキル定義（半減期）
    - タグ→スキルの重み付けルール
    - 重複排除キー
    - 状態管理
    - エラーモデル
    - 監視・ログ
    - レート制限
    - 再計算の再現性
    - リリース手順
- 5項目を決めようとしたけどそもそもどうやってこれを決めるのかわからなかったから、どういう流れ、考え方で決めるのかAIに聞いた
    - 結論
        - **出力から逆算**（誰に、何を、どんな形で返す？）
        - **イベントを集める**（何が起きたらデータが生まれる？）
        - **保存と再計算を分ける**（原データと表示用データは別テーブル）
        - **一意性と時系列を決める**（重複排除キー＆発生日時）
        - **1週間回してから足す**（足りない列は使いながら増やす）
    - 詳しい答え
        
        ## 1) 出力から逆算（Outputs → APIs → DB）
        
        ### 実際に欲しい出力（画面/API）を書き出す
        
        - Analytics 画面：
            - 「直近90日の技術別スコア（レーダー）」
            - 「月次推移（棒グラフ）」
            - 「GitHubの草」
        - Home 画面：
            - 「最近の活動 3件」
        
        ### その出力をAPIに落とす
        
        - `GET /scores?days=90` → `{ "react": 128.4, "next": 96.2, ... }`
        - `GET /activities?limit=3` → 最近のイベント
        
        👉 ここまで決めると、「**どんなデータを保存しとけば、これが作れるか**？」が見える。
        
        ---
        
        ## 2) イベントを集める（Event-first）
        
        画面の裏側で「何が起きたら記録すべき？」を**箇条書き**：
        
        - 記事を書いた（RSS で取得できる）
        - PR がマージされた（GitHub Webhook）
        - ポートフォリオに新プロジェクトを追加した（自分で登録）
        
        これらは全部「**出来事（イベント）**」。
        
        イベントには必ず**発生日時（happenedAt）**と**外部参照（url や commit_sha）**がある。
        
        👉 だから**Activity**テーブルが要る：
        
        `id, actionId, happenedAt, url(一意), source, status, meta, tags …`
        
        > なんでわかるの？
        > 
        > 
        > → “再現性”。**あとから同じ集計がやり直せる**ように、原データ（イベント）を**そのまま**残しておく必要があるから。
        > 
        
        ---
        
        ## 3) 保存と再計算を分ける（Event → Projection）
        
        - 画面は「直近90日の集計」「月ごとの合計」など**集計**を多用する
        - 毎回生の Activity から計算すると**遅い/高コスト**
        - だから**日次の確定値**を別テーブルに持つ：**ScoreDaily**
        
        👉 **ScoreDaily** の役割は「**投影（Projection）**」
        
        `skillId, date, points` を日付×スキルで固めておく。
        
        これを足し算すれば、レーダーも棒グラフも**即座に**描ける。
        
        > なんでわかるの？
        > 
        > 
        > → “読み取り頻度”。**よく読む形に前もって整形**しておくと速い。集計はジョブで後ろに回す。
        > 
        
        ---
        
        ## 4) 一意性と時系列を決める（Idempotency & Time）
        
        どのレコードが**同じものか**を定義する（重複排除の基準）：
        
        - 記事・PR：**url** が一意
        - コミット：**commit_sha** が一意（必要になったら列を足す）
        
        そして**時系列**は必須：
        
        - いつ起きたか（`happenedAt`）
        - 日次集計のキー（`date`）
        - これがないと**減衰（最近ほど重視）**も、**月次集計**もできない
        
        > なんでわかるの？
        > 
        > 
        > → 集計の基本は**識別子×時間**。ここが曖昧だと全体が崩れる。
        > 
        
        ---
        
        ## 5) 1週間回してから足す（YAGNI & 実測）
        
        最初から完璧にしない。
        
        **最低限の列**で走らせ、**“困ったときに”** 列を追加する。
        
        - たとえば品質係数が欲しくなったら `meta.wordCount` や `meta.reactions` を足す
        - OSS の区別が欲しくなったら `tags` に `["oss"]` を入れるルールを後付け
        
        > なんでわかるの？
        > 
        > 
        > → 一人開発は**スピード命**。**実データを入れて回してから**、必要な列が“見えてくる”。
        > 
        
        ---
        
        # じゃあ「そのテーブルが必要」かを判断する基準
        
        ### Activity（イベント表）
        
        - これがないと：**いつ、何が**行われたかが消える → 透明性ゼロ・再計算不可
        - これがあると：証跡リンク（url）で**根拠**が残り、**後から計算式を変えても再現**できる
        
        ### ScoreDaily（日次投影）
        
        - これがないと：毎回**全件スキャン**して計算 → 遅い、料金も痛い
        - これがあると：**足し算だけ**でグラフが出る、前日比や月次も一瞬
        
        > 結論：
        > 
        > - “**発生した事実**”を保存する→**Activity**
        > - “**よく使う形**”に整形しておく→**ScoreDaily**
        
        この2枚が**最小構成**。足りなくなったら**参照テーブル**（Skill 定義など）を足す。
        
        ---
        
        # 一人で決めるときの「順番テンプレ」
        
        1. **スクショでOKのUIモック**を作る（何を見せたいかを固める）
        2. UIに必要な**APIの返却JSON**を書いてみる（キー名・型・例）
        3. そのJSONを作るために**最小のテーブル**を設計（Activity / ScoreDaily）
        4. **一意キー**と**日時**を必ず決める（重複/集計のため）
        5. **異常系**（エラー時・重複時・無効データ）を1つずつ決める
        6. **ジョブのタイミング**を決める（いつ取り込み・いつ再計算）
        7. 実データを**10〜50件だけ**入れて、APIを叩いて**体感**する
        8. 足りない列だけ**後付け**（Prismaならマイグレ楽勝）
        
        ---
        
        # 具体：あなたのケースで当てはめると
        
        - UIモック：Analyticsに**レーダー＋月次棒＋草**
        - API返却：`GET /scores?days=90` → `{react:128.4,...}`
        - テーブル：Activity / ScoreDaily（上記の定義）
        - 一意キー：`Activity.url`（PR/記事）
        - 時間：`happenedAt`（イベント時刻）/ `date`（日次キー）
        - 異常系：署名不一致のWebhook→401、days不正→400
        - ジョブ：**03:00 JST**に再計算、RSSは最初手動→後でCron
        - 実データ：RSSから10件pull、/scoresの見え方を確認
        - 足し込み：必要になったら `commit_sha` や `quality` を追加
        
        ---
        
        # よくある落とし穴（回避策つき）
        
        - **“完成DB”を先に作る** → 8割いらない列になる
            - ✅ **最小テーブル**で走らせる → 使いながら列を足す
        - **集計を都度クエリ** → そのうち遅くなる
            - ✅ **ScoreDaily** に投影 → 表示は足し算だけ
        - **重複データが溜まる** → 数字がズレる
            - ✅ `url`（or `commit_sha`）で **UPSERT**
        - **エラーモデルが曖昧** → デバッグ地獄
            - ✅ 400/401/500 を文字列コードで**固定**（ログで追える）
- 上記をもって思ったのは、先にFEのモック作った方がいい、、？
    - 結論
        - その方がスムーズっぽい
    - 詳しい答え
        
        うん、今回みたいな**個人開発＋要件がまだ固まりきってない状態**なら、
        
        先にFEモック（UIの形）を作ったほうが絶対スムーズになるよ。
        
        理由は3つ👇
        
        ---
        
        ## 1. DBやAPI設計の精度が上がる
        
        - モックがあると、「どんな項目が表示されるか」が**視覚的に確定**する
        - そこから逆算してAPIの返却JSONを定義できる
        - 返却JSONから必要なDB列やテーブルが決まる
            
            → **無駄なカラムやテーブルが減る**
            
        
        ---
        
        ## 2. 「要らない機能」を早期に捨てられる
        
        - モックを並べてみると、「これ今いらなくない？」が見える
        - 要件定義の文章だけだと全部必要に見えるけど、
            
            実際UIに置くと優先度が低い機能は自然に消える
            
            → **MVPがコンパクトになる**
            
        
        ---
        
        ## 3. 実装モチベが上がる
        
        - コード書く前に完成イメージがあると進捗感が出やすい
        - デザイン決めてる段階で色やコンポーネントも揃えられる
        - FE → BEの順で進めると、「UIが動く喜び」を先に味わえる
            
            → **継続しやすい**
            
        
        ---
        
        ### おすすめの流れ（今回の場合）
        
        1. **FigmaやMiroで画面モック作成**
            - Home / About / Projects / Analytics / Contact
            - スマホとPC両方（ざっくりでOK）
        2. **モックに載ってる項目名を全部リスト化**
            - 「ここは数値」「ここは画像URL」「ここは日付」など型をメモ
        3. **その項目を返すAPIの返却JSONを書く**
            - 例：`GET /analytics` → `{ "skills": [...], "monthly": [...] }`
        4. **APIに必要なDBカラムを洗い出す**
            - Activity / ScoreDaily のどっちから出すか分ける
        5. **BE設計に着手**
- 上記の質問の意味はFEのコードを書くべきかと思ったけど、figmaのワイヤーフレームを作った方がいいみたい
    - それはそう
- figma作ってみようかな
    - AIがモック構成テンプレを作ってくれた
        
        ### **Home**
        
        - **Header**（名前・肩書き）
        - **Hero**（ファーストビュー＋自己紹介文）
        - **Featured Projects**（代表プロジェクト3つ）
        - **Skills Overview**（簡易スキルランキング）
        - **Recent Activity**（最新記事・GitHub更新）
        - **Contact CTA**（フォームへの導線）
        - **Footer**
        
        ---
        
        ### **About**
        
        - **Profile Header**（名前・写真・キャッチコピー）
        - **Biography**（経歴）
        - **Interests**（興味関心）
        - **Full Skill Map**（スキルマップ全体）
        - **Self PR**
        - **Footer**
        
        ---
        
        ### **Projects**
        
        - **Project Cards**（課題→解決→技術→成果）
        - **Articles List**（記事一覧）
        - **GitHub Sample Links**
        - **Footer**
        
        ---
        
        ### **Analytics**
        
        - **Stats Overview**（リポジトリ数・コミット数など）
        - **Tech Stack Ranking**（棒グラフ）
        - **Monthly Trends**（折れ線）
        - **Radar Chart**（総合スキルバランス）
        - **Score Rules**（スコア算出ルール）
        - **Footer**
        
        ---
        
        ### **Contact**
        
        - **Contact Form**（名前 / メール / 用件 / 本文）
        - **Alternative Contact**（Slack・SNSリンク）
        - **Footer**
    - テンプレ構成を図にした画像を作ってくれた(使えなさそう、、)
        
        ![figma_portfolio_structure.png](attachment:9dd71dd3-af72-4fa5-b057-bc116bfe6eca:figma_portfolio_structure.png)
        
    - ちょっといい感じ
        
        ![ChatGPT Image 2025年8月13日 15_56_44.png](attachment:00ccb642-19d1-43a6-b210-acc0cbe0f614:ChatGPT_Image_2025年8月13日_15_56_44.png)
        
- けどモック作りづらいな、、
- 一旦実際にコーディングをして、デザインはcursorに任せる？
- あ、piterest頼ろう！
    - ここでまた色々迷っちゃって先に進まないからやっぱcursorに作ってもらう
- 次に進むことにした
- そういえばディレクトリ構成決めてなかった
    -
